package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path/filepath"

	"github.com/gorilla/mux"
	"github.com/hyperledger/fabric-sdk-go/pkg/core/config"
	"github.com/hyperledger/fabric-sdk-go/pkg/gateway"
	"github.com/joho/godotenv"
)

type Patient struct {
	PId             string `json:"pid"`
	UId             int    `json:"uid"`
	Name            string `json:"name"`
	Birthday        string `json:"birthday"`
	Gender          string `json:"gender"`
	Pasthistory     string `json:"pasthistory"`
	Allergichistory string `json:"allergichistory"`
	Height          int    `json:"height"`
	Weight          int    `json:"weight"`
	Status          string `json:"status"`
}

type Illness struct {
	SId         string `json:"sid"`
	PId         string `json:"pid"`
	DocId       string `json:"docid"`
	DateTime    string `json:"datetime"`
	Name        string `json:"name"`
	Description string `json:"description"`
}

type Diagnosis struct {
	DId         string `json:"did"`
	SId         string `json:"sid"`
	PId         string `json:"pid"`
	DocId       string `json:"docid"`
	DateTime    string `json:"datetime"`
	Catagory    string `json:"catagory"`
	Description string `json:"description"`
	Temperature int    `json:"temperature"`
	Systolicbp  int    `json:"systolicbp"`
	Diastolicbp int    `json:"diastolicbp"`
	HeartRate   int    `json:"heartrate"`
	Advice      string `json:"advice"`
}

type Prescription struct {
	PscId       string `json:"pscid"`
	DId         string `json:"did"`
	PId         string `json:"pid"`
	DocId       string `json:"docid"`
	DateTime    string `json:"datetime"`
	Catagory    string `json:"catagory"`
	Description string `json:"description"`
	CustomUsage string `json:"customusage"`
	Quantity    int    `json:"quantity"`
}

func homeLink(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Welcome home!")
}

var contract *gateway.Contract
var fabricHome, orgName, peerName, configFileName, userName string

func init() {
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}
	orgName = os.Getenv("API_ORG")

	peerName = os.Getenv("API_PEER")

	configFileName = os.Getenv("API_CONFIG_FILE_NAME")

	userName = os.Getenv("API_USER_NAME")

	fabricHome = os.Getenv("API_FABRIC_HOME")
	log.Println("============ Initailizing wallet ============")

	// Start discovery as localhost
	// TODO: Need to check if this needs to removed in prod
	err = os.Setenv("DISCOVERY_AS_LOCALHOST", "true")
	if err != nil {
		log.Fatalf("Error setting DISCOVERY_AS_LOCALHOST environemnt variable: %v", err)
	}
	//region WALLET CODE.
	wallet, err := gateway.NewFileSystemWallet("wallet")
	if err != nil {
		log.Fatalf("Failed to create wallet: %v", err)
	}

	if !wallet.Exists("appUser") {
		err = populateWallet(wallet)
		if err != nil {
			log.Fatalf("Failed to populate wallet contents: %v", err)
		}
	}
	//endregion End of wallet code.

	//r Create file path to the config generated by generatePeerConfig.sh
	ccpPath := filepath.Join(
		fabricHome,
		// "..",
		// "test-network",
		"organizations",
		"peerOrganizations",
		orgName,
		configFileName,
	)
	log.Println("Connecting Gateway to: \n" + ccpPath)
	//region GATEWAY CODE.
	gw, err := gateway.Connect(
		gateway.WithConfig(config.FromFile(filepath.Clean(ccpPath))),
		gateway.WithIdentity(wallet, "appUser"),
	)
	if err != nil {
		log.Fatalf("Failed to connect to gateway: %v", err)
	}
	defer gw.Close()
	//endregion End of gatewat connect code.

	network, err := gw.GetNetwork("general-medicine-channel")
	if err != nil {
		log.Fatalf("Failed to get network: %v", err)
	}

	contract = network.GetContract("healthContract")
}

func getPatient(w http.ResponseWriter, r *http.Request) {
	log.Println("============ Processing get patient call ============")

	vars := mux.Vars(r)
	log.Println("--> Evaluate Transaction: Getting patient " + vars["id"])
	result, err := contract.EvaluateTransaction("ReadPatient", vars["id"])
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	if err != nil {
		log.Println("Failed to Get Asset: %v", err)

		json.NewEncoder(w).Encode(err.Error())

	} else {
		log.Println(string(result))
		var response map[string]interface{}
		if err := json.Unmarshal(result, &response); err != nil {
			panic(err)
		}
		json.NewEncoder(w).Encode(response)
	}
}

func admitPatient(w http.ResponseWriter, r *http.Request) {
	var newPatient Patient
	log.Println("============ Processing admit patient call ============")

	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		fmt.Fprintf(w, "Kindly enter data with the neccessary fields")
	}

	json.Unmarshal(reqBody, &newPatient)

	log.Println("--> Submit Transaction: AdmitPatient, creates new patient")
	// result, err = contract.SubmitTransaction("AdmitPatient", newPatient.PId, newPatient.UId, newPatient.Name, newPatient.Birthday, newPatient.Gender, newPatient.Pasthistory, newPatient.Allergichistory, newPatient.Height, newPatient.Weight, newPatient.Status)
	result, err := contract.SubmitTransaction("AdmitPatient", string(reqBody))
	// result, err := contract.SubmitTransaction("Create", "key112121", "value9182349")
	if err != nil {
		log.Println("Failed to Submit transaction: %v", err)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusCreated)
		json.NewEncoder(w).Encode(err.Error())

	} else {
		log.Println(string(result))
		// newPatients = append(newPatients, newPatient)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusCreated)

		json.NewEncoder(w).Encode(newPatient)
	}
	log.Println("============ Completed admit patient call ============")
}
func getSymptoms(w http.ResponseWriter, r *http.Request) {
	log.Println("============ Processing get symptoms call ============")

	vars := mux.Vars(r)
	log.Println("--> Evaluate Transaction: Getting Symptoms " + vars["id"])
	result, err := contract.EvaluateTransaction("ReadSymptoms", vars["id"])
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	if err != nil {
		log.Println("Failed to Get Symptoms: %v", err)

		json.NewEncoder(w).Encode(err.Error())

	} else {
		log.Println(string(result))
		var response map[string]interface{}
		if err := json.Unmarshal(result, &response); err != nil {
			panic(err)
		}
		json.NewEncoder(w).Encode(response)
	}
}
func noteSymptoms(w http.ResponseWriter, r *http.Request) {
	var newSymptoms Illness
	log.Println("============ Processing note symptoms call ============")
	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		fmt.Fprintf(w, "Kindly enter data with the neccessary fields")
	}
	json.Unmarshal(reqBody, &newSymptoms)
	log.Println("--> Submit Transaction: AdmitPatient, creates new patient")
	result, err := contract.SubmitTransaction("NoteSymptoms", string(reqBody))
	if err != nil {
		log.Println("Failed to Submit transaction: %v", err)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusCreated)
		json.NewEncoder(w).Encode(err.Error())

	} else {
		log.Println(string(result))
		// newPatients = append(newPatients, newPatient)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusCreated)

		json.NewEncoder(w).Encode(newSymptoms)
	}
	log.Println("============ Completed note symptoms call ============")

}

func getDiagnosis(w http.ResponseWriter, r *http.Request) {
	log.Println("============ Processing get dignosis call ============")

	vars := mux.Vars(r)
	log.Println("--> Evaluate Transaction: Getting dignosis " + vars["id"])
	result, err := contract.EvaluateTransaction("ReadDiagnosis", vars["id"])
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	if err != nil {
		log.Println("Failed to Get dignosis: %v", err)

		json.NewEncoder(w).Encode(err.Error())

	} else {
		log.Println(string(result))
		var response map[string]interface{}
		if err := json.Unmarshal(result, &response); err != nil {
			panic(err)
		}
		json.NewEncoder(w).Encode(response)
	}
}

func dignosePatient(w http.ResponseWriter, r *http.Request) {
	var newDiagnosis Diagnosis
	log.Println("============ Processing dignose patient call ============")
	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		fmt.Fprintf(w, "Kindly enter data with the neccessary fields")
	}

	json.Unmarshal(reqBody, &newDiagnosis)
	result, err := contract.SubmitTransaction("DiagnosePatient", string(reqBody))
	if err != nil {
		log.Println("Failed to Submit transaction: %v", err)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusCreated)
		json.NewEncoder(w).Encode(err.Error())

	} else {
		log.Println(string(result))
		// newPatients = append(newPatients, newPatient)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusCreated)

		json.NewEncoder(w).Encode(newDiagnosis)
	}
	log.Println("============ Completed dignose patient call ============")
}

func getPrescription(w http.ResponseWriter, r *http.Request) {
	log.Println("============ Processing get prescription call ============")

	vars := mux.Vars(r)
	log.Println("--> Evaluate Transaction: Getting prescription " + vars["id"])
	result, err := contract.EvaluateTransaction("ReadPrescription", vars["id"])
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	if err != nil {
		log.Println("Failed to Get prescription: %v", err)

		json.NewEncoder(w).Encode(err.Error())

	} else {
		log.Println(string(result))
		var response map[string]interface{}
		if err := json.Unmarshal(result, &response); err != nil {
			panic(err)
		}
		json.NewEncoder(w).Encode(response)
	}
}

func writePrescription(w http.ResponseWriter, r *http.Request) {
	var newPrescription Prescription
	log.Println("============ Processing write prescription call ============")
	reqBody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		fmt.Fprintf(w, "Kindly enter data with the neccessary fields")
	}

	json.Unmarshal(reqBody, &newPrescription)
	result, err := contract.SubmitTransaction("WritePrescription", string(reqBody))
	if err != nil {
		log.Println("Failed to Submit transaction: %v", err)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusCreated)
		json.NewEncoder(w).Encode(err.Error())

	} else {
		log.Println(string(result))
		// newPatients = append(newPatients, newPatient)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusCreated)

		json.NewEncoder(w).Encode(newPrescription)
	}
	log.Println("============ Completed write prescription call ============")
}

func main() {
	router := mux.NewRouter().StrictSlash(true)
	router.HandleFunc("/", homeLink)
	router.HandleFunc("/getPatient/{id}", getPatient)
	router.HandleFunc("/getSymptoms/{id}", getSymptoms)
	router.HandleFunc("/getDiagnosis/{id}", getDiagnosis)
	router.HandleFunc("/getPrescription/{id}", getPrescription)
	router.HandleFunc("/admitPatient", admitPatient).Methods("POST")
	router.HandleFunc("/noteSymptoms", noteSymptoms).Methods("POST")
	router.HandleFunc("/dignosePatient", dignosePatient).Methods("POST")
	router.HandleFunc("/writePrescription", writePrescription).Methods("POST")
	log.Fatal(http.ListenAndServe(":8080", router))
}

func populateWallet(wallet *gateway.Wallet) error {
	log.Println("============ Populating wallet ============")
	credPath := filepath.Join(
		fabricHome,
		// "..",
		// "test-network",
		"organizations",
		"peerOrganizations",
		orgName,
		"users",
		userName+"@"+orgName,
		"msp",
	)
	log.Println("Credential Path : " + credPath)

	certPath := filepath.Join(credPath, "signcerts", "cert.pem")
	// read the certificate pem
	cert, err := ioutil.ReadFile(filepath.Clean(certPath))
	if err != nil {
		return err
	}

	keyDir := filepath.Join(credPath, "keystore")
	// there's a single file in this dir containing the private key
	files, err := ioutil.ReadDir(keyDir)
	if err != nil {
		return err
	}
	if len(files) != 1 {
		return fmt.Errorf("keystore folder should have contain one file")
	}
	keyPath := filepath.Join(keyDir, files[0].Name())
	key, err := ioutil.ReadFile(filepath.Clean(keyPath))
	if err != nil {
		return err
	}

	identity := gateway.NewX509Identity("AshwiniHospitalMSP", string(cert), string(key))

	return wallet.Put("appUser", identity)
}
